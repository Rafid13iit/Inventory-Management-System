from rest_framework import serializers
# Importing the `serializers` module from Django REST Framework (DRF).
# DRF is an extension of Django that simplifies building RESTful APIs.
# Serializers are used to convert complex data types (like Django models) into JSON (or other formats) 
# and vice versa. This is essential for APIs to communicate with clients.

from .models import Category, Product, Sale
# Importing the `Category`, `Product`, and `Sale` models from the local `models.py` file.
# Models in Django define the structure of your database tables and are the foundation of your application.
# Each model corresponds to a table in the database.

class CategorySerializer(serializers.ModelSerializer):
    # A serializer for the `Category` model.
    # `ModelSerializer` is a DRF class that automatically generates fields based on the model.

    class Meta:
        model = Category
        # Specifies the model this serializer is based on (`Category` in this case).
        
        fields = ['id', 'name', 'description', 'created_at', 'updated_at']
        # Defines the fields to include in the serialized output.
        # These fields will be converted to JSON when the API sends data to the client.

        read_only_fields = ['id', 'created_at', 'updated_at']
        # Specifies fields that cannot be modified by the client.
        # `id` is typically read-only because it's auto-generated by the database.
        # `created_at` and `updated_at` are timestamps that are usually managed automatically.

# **Django Concept: Models and Serializers**
# - Models define the database schema and business logic.
# - Serializers handle the conversion of model instances to JSON (serialization) and JSON to model instances (deserialization).
# - DRF's `ModelSerializer` simplifies this process by automatically generating fields based on the model.

class ProductSerializer(serializers.ModelSerializer):
    # A serializer for the `Product` model.

    category_name = serializers.ReadOnlyField(source='category.name')
    # A read-only field that retrieves the `name` of the related `category` object.
    # `source='category.name'` means it fetches the `name` attribute from the related `category` model.
    # This is an example of how to include related model data in a serializer.

    is_low_stock = serializers.BooleanField(read_only=True)
    # A read-only field that indicates whether the product is low in stock.
    # This field is not directly tied to the model but can be calculated dynamically.

    class Meta:
        model = Product
        # Specifies the model this serializer is based on (`Product` in this case).

        fields = [
            'id', 'name', 'category', 'category_name', 'price', 'quantity',
            'description', 'image', 'is_low_stock', 'created_at', 'updated_at'
        ]
        # Defines the fields to include in the serialized output.

        read_only_fields = ['id', 'created_at', 'updated_at']
        # Specifies fields that cannot be modified by the client.

# **Django Concept: Relationships**
# - The `category` field in the `Product` model is likely a `ForeignKey` to the `Category` model.
# - This establishes a one-to-many relationship (one category can have many products).
# - DRF allows you to include related data (like `category_name`) in serializers using the `source` attribute.

class ProductListSerializer(ProductSerializer):
    # A specialized serializer for listing products.
    # It inherits from `ProductSerializer` but overrides the fields.

    class Meta(ProductSerializer.Meta):
        # Inherits the `Meta` class from `ProductSerializer`.

        fields = [
            'id', 'name', 'category_name', 'price', 'quantity',
            'is_low_stock', 'image'
        ]
        # Defines a subset of fields for listing products.
        # This is useful for optimizing API responses by excluding unnecessary data.

# **Best Practice: Separate Serializers**
# - Use different serializers for different use cases (e.g., detailed view vs. list view).
# - This improves performance and reduces the amount of data sent over the network.

class SaleSerializer(serializers.ModelSerializer):
    # A serializer for the `Sale` model.

    product_name = serializers.ReadOnlyField(source='product.name')
    # A read-only field that retrieves the `name` of the related `product` object.

    created_by_username = serializers.ReadOnlyField(source='created_by.username')
    # A read-only field that retrieves the `username` of the user who created the sale.
    # This assumes the `created_by` field is a `ForeignKey` to Django's `User` model.

    class Meta:
        model = Sale
        # Specifies the model this serializer is based on (`Sale` in this case).

        fields = [
            'id', 'product', 'product_name', 'quantity', 'unit_price',
            'total_price', 'sale_date', 'created_by', 'created_by_username'
        ]
        # Defines the fields to include in the serialized output.

        read_only_fields = ['id', 'total_price', 'created_by']
        # Specifies fields that cannot be modified by the client.

    def validate(self, attrs):
        # Custom validation logic for the `Sale` serializer.

        product = attrs['product']
        # Retrieves the `product` object from the validated data.

        quantity = attrs['quantity']
        # Retrieves the `quantity` from the validated data.

        if product.quantity < quantity:
            # Checks if the requested quantity exceeds the available stock.

            raise serializers.ValidationError(
                f"Not enough stock available. Only {product.quantity} units left."
            )
            # Raises a validation error if there is insufficient stock.

        return attrs
        # Returns the validated data if no errors are found.

    def create(self, validated_data):
        # Custom logic for creating a `Sale` instance.

        validated_data['created_by'] = self.context['request'].user
        # Sets the `created_by` field to the currently authenticated user.
        # `self.context['request']` provides access to the HTTP request object.

        validated_data['unit_price'] = validated_data['product'].price
        # Sets the `unit_price` field to the price of the product being sold.

        return super().create(validated_data)
        # Calls the `create` method of the parent class (`ModelSerializer`) to save the instance.

# **Django Concept: Validation**
# - DRF allows you to add custom validation logic in serializers using the `validate` method.
# - This is useful for enforcing business rules (e.g., checking stock availability).

# **Django Concept: Context**
# - The `context` dictionary in serializers provides additional data, such as the current request.
# - This is useful for accessing the authenticated user or other request-specific information.

# **Best Practice: Validation**
# - Perform validation in the serializer to ensure data integrity before saving to the database.
# - Use `validate` for general validation and `validate_<fieldname>` for field-specific validation.